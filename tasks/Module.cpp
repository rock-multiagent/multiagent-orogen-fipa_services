#include "Module.hpp"

#include <semaphore.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>

#include <message-generator/ACLMessageOutputParser.h>
#include <rtt/corba/ControlTaskProxy.hpp>
#include <rtt/corba/ControlTaskServer.hpp>
#include <rtt/NonPeriodicActivity.hpp>

#include "TypelibMarshallerBase.hpp"

#include "module_id.h"

namespace dc = dfki::communication;
namespace rc = RTT::Corba;

namespace root
{
////////////////////////////////////////////////////////////////////
//                           PUBLIC                               //
////////////////////////////////////////////////////////////////////
Module::Module(std::string const& name) : ModuleBase(name),
        fipa(),
        connections(),
        mta(NULL),
        loggerNames(),
        serviceDiscovery(NULL),
        transport(NULL),
        modID(name),
        connectSem(NULL)
{
    connectSem = new sem_t();
    sem_init(connectSem, 1, 1);
}

Module::~Module()
{
    if(serviceDiscovery != NULL)
    {
        delete serviceDiscovery;
        serviceDiscovery = NULL;
    }
    // Delete all the remote connections.
    std::map<std::string, ConnectionInterface*>::iterator it;
    for(it=connections.begin(); it != connections.end(); it++)
    {
        it->second->disconnect();
        delete(it->second);
        it->second = NULL;
    }
    connections.clear();
    // The mts-connection has been deleted as well.
    mta = NULL;
    delete connectSem;
    connectSem = NULL;
    stop();
    // See 'cleanupHook()'.
}

////////////////////////////////HOOKS///////////////////////////////
bool Module::configureHook()
{
    // Set logger info.
    if (RTT::log().getLogLevel() < RTT::Logger::Info)
    {
        RTT::log().setLogLevel( RTT::Logger::Info );
    }

    // If configure properties are empty, module will be stopped.
    if(_module_name.get().empty() || _avahi_type.get().empty() || _avahi_port.get() == 0)
    {
        globalLog(RTT::Info, "Properties are not set, module will be stopped.");
        return false;
    }
    // Set name of this task context.
    this->setName(_module_name.get());
    // Split and store module ID to envID, avahi type and name.
    modID = ModuleID(_module_name.get());

    // Configure SD.
    dc::ServiceConfiguration sc(_module_name.get(), _avahi_type.get(), _avahi_port.get());
    sc.setTTL(_avahi_ttl.get());
    sc.setDescription("IOR", RTT::Corba::ControlTaskServer::getIOR(this));
    serviceDiscovery = new dc::ServiceDiscovery();
    // conf.stringlist.push_back("Type=Basis");
    // Add calback functions.
    serviceDiscovery->addedComponentConnect(sigc::mem_fun(*this, 
        &Module::serviceAdded));
    serviceDiscovery->removedComponentConnect(sigc::mem_fun(*this, 
        &Module::serviceRemoved));
    // Start SD.
    try{
        serviceDiscovery->start(sc);
    } catch(exception& e) {
        globalLog(RTT::Error, "%s", e.what());
    }
    globalLog(RTT::Info, "Started service '%s'. Avahi-type: '%s'. Port: %d. TTL: %d.", 
        _module_name.get().c_str(), _avahi_type.get().c_str(), _avahi_port.get(), _avahi_ttl.get());

    // Required?
    // Getting information for the type of the ports (fipa::BitefficientMessage)
    RTT::TypeInfo const* type = _inputPortMTS.getTypeInfo();
    transport = dynamic_cast<orogen_transports::TypelibMarshallerBase*>(
        type->getProtocol(orogen_transports::TYPELIB_MARSHALLER_ID));
    if (! transport)
    {
        // TODO change the log
        log(RTT::Error) << "cannot report ports of type " << type->getTypeName()
         << " as no toolkit generated by orogen defines it" << RTT::endlog();
    } 
    return true;
}

void Module::errorHook()
{
    globalLog(RTT::Error, "Entering error state.");
}

bool Module::startHook()
{
    return true;
}

void Module::stopHook()
{
}

void Module::updateHook(std::vector<RTT::PortInterface*> const& updated_ports)
{
    std::vector<RTT::PortInterface*>::const_iterator it;
    // Process message of all updated ports.
    for(it = updated_ports.begin(); it != updated_ports.end(); ++it)
    { 
        fipa::BitefficientMessage message;
        RTT::InputPortInterface* read_port = dynamic_cast<RTT::InputPortInterface*>(*it);
        ((RTT::InputPort<fipa::BitefficientMessage>*)read_port)->read(message);
        globalLog(RTT::Info, "Received new message on port %s of size %d", (*it)->getName().c_str(),
                message.size());
        std::string msg_str = message.toString();
        processMessage(msg_str);
    }
}

////////////////////////////////////////////////////////////////////
//                           PROTECTED                            //
////////////////////////////////////////////////////////////////////
void Module::globalLog(RTT::LoggerLevel log_type, const char* format, ...)
{
    int n = 100;	
	char buffer[512];
	va_list arguments;

	va_start(arguments, format);
	n = vsnprintf(buffer, sizeof(buffer), format, arguments);
	va_end(arguments);
    std::string msg(buffer);

    // Global log, sending message to all log-modules.
    if(loggerNames.size()) // Are log-modules active?
    {
        // Build logging string with 'RTT::Logger/modname/msg'.
        std::string log_msg = "x/" + this->getName() + "/" + msg;
        log_msg[0] = static_cast<int>(log_type); // log_type 0-6

        if(mta)
        {
            // Create message
            try {
                fipa.clear();
                fipa.setMessage("SENDER "+ this->getName() + 
                        "CONTENT START " + log_msg + " STOP");
                fipa.setParameter("RECEIVER", loggerNames);
                mta->send(fipa.encode());
            } catch (MessageException& e) {
                log(RTT::Warning) << "MessageException: " << e.what() << RTT::endlog();
            } catch (ConnectionException& e) {
                log(RTT::Warning) << "ConnectionException: " << e.what() << RTT::endlog();
            }
        }
    }
    // Local log.
    log(log_type) << msg << RTT::endlog();
}

bool Module::processMessage(std::string& message)
{
    // If not overwritten, just send all messages back to the sender.
    if(mta == NULL)
    {
        log(RTT::Warning) << "No MTA available." << RTT::endlog();
        return false;
    }
    try
    {
        fipa.decode(message);
        // Set new sender and receiver.
        std::string sender = fipa.getEntry("SENDER").at(0);
        fipa.clear("RECEIVER SENDER");
        fipa.setMessage("RECEIVER "+sender);
        fipa.setMessage("SENDER "+modID.getID());
        mta->send(fipa.encode());
    }
    catch(ConnectionException& e)
    {
        log(RTT::Warning) << "ConnectionException: " << e.what() << RTT::endlog();
        return false;
    }
    catch(MessageException& e)
    {
        log(RTT::Warning) << "MessageException: " << e.what() << RTT::endlog();
        return false;
    }
    
    return true;
}

////////////////////////////////RPC-METHODS//////////////////////////
bool Module::rpcCreateConnectPorts(std::string const& remote_name, 
        std::string const& remote_ior)
{
    //sem_wait(connectSem);   
    // Return true if the connection have already be established.
    if(connections.find(remote_name) != connections.end())
    {
        globalLog(RTT::Warning, "(RPC) Connection to '%s' already established", 
            remote_name.c_str());
        //sem_post(connectSem);
        return true;
    }
    
    // Create the ports and the proxy and use the proxy to connect 
    // the local output to the remote input.
    CorbaConnection* con = new CorbaConnection(this, remote_name, remote_ior);
    try {
        con->connectLocal();
    } catch(ConnectionException& e) {
        globalLog(RTT::Error, "(RPC) Connection to '%s' could not be established: %s", 
                remote_name.c_str(), e.what());
        //sem_post(connectSem);
        return false;
    }

    connections.insert(pair<std::string, CorbaConnection*>(remote_name,con));
    globalLog(RTT::Info, "(RPC) Connected to '%s'", remote_name.c_str());
    //sem_post(connectSem);
    return true;
}

////////////////////////////////CALLBACKS///////////////////////////
void Module::serviceAdded_(dfki::communication::ServiceEvent& se)
{
    //sem_wait(connectSem) ;
    std::string id = se.getServiceDescription().getName();

    // Do not connect to yourself.
    if(id == this->getName())
    {
        return;
    }

    std::map<std::string, ConnectionInterface*>::iterator it;
    it = connections.find(id);

    if(it != connections.end())
    {
        log(RTT::Info) << "Connection to " << id << " already established." 
                << RTT::endlog();
        //sem_post(connectSem);
        return;
    }

    ModuleID mod(id);
    std::string remoteIOR = se.getServiceDescription().getDescription("IOR");

    // Connect to the first appropriate MTA (same environment ids).  
    // TEST: Connect to A_ROOT_1
    if(mta == NULL && (mod.getType() == "MTA" && mod.getEnvID() == this->modID.getEnvID()))
    {
        CorbaConnection* cc = new CorbaConnection(this, id, remoteIOR);
        try{
            cc->connect();
        } catch(ConnectionException& e) {
            log(RTT::Info) << "ConnectionException: " << e.what() << RTT::endlog();
            //sem_post(connectSem);
            return;        
        }
        connections.insert(pair<std::string, CorbaConnection*>(id,cc));
        log(RTT::Info) << "Connected to " << id << RTT::endlog();
    }

    // Build up a list with all the logging-module-IDs.  
    if(mod.getType() == "LOG")
    {
        loggerNames.push_back(id);
    }
    //sem_post(connectSem);
}

void Module::serviceRemoved_(dfki::communication::ServiceEvent& se)
{
    // Do nothing if no connection is available.
    std::string id = se.getServiceDescription().getName();
    std::map<std::string, ConnectionInterface*>::iterator it = connections.find(id);
    if(it == connections.end()) // No connection to 'id' available.
        return;

    ModuleID mod(id);

    // If its the MTA of this module, remove shortcut.
    if(mod.getType() == "MTA" && mod.getEnvID() == this->modID.getEnvID())
    {
        mta = NULL;
        globalLog(RTT::Warning, "My MTA has been removed.");
    } 

    // If its a logging module, remove entry in the logger list.
    if(mod.getType() == "LOG")
    {
        std::vector<std::string>::iterator it=loggerNames.begin();
        for(; it!=loggerNames.end(); ++it)
        {
            if(*it == id)
            {
                loggerNames.erase(it);
                break;
            }
        }
    }

    // Disconnect and delete.
    it->second->disconnect();
    connections.erase(it);

    log(RTT::Info) << "Disconnected from " << id << RTT::endlog();
}

////////////////////////////////////////////////////////////////////
//                           PRIVATE                              //
////////////////////////////////////////////////////////////////////
Module::Module() : ModuleBase("root::Module"), modID("root::Module"){}

void Module::serviceAdded(dfki::communication::ServiceEvent se)
{
    globalLog(RTT::Info, "New module %s added", se.getServiceDescription().getName().c_str());
    serviceAdded_(se);
}

void Module::serviceRemoved(dfki::communication::ServiceEvent se)
{
    globalLog(RTT::Info, "Module %s removed", se.getServiceDescription().getName().c_str());
    serviceRemoved_(se);
}
} // namespace modules

